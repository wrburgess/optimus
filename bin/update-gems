#!/usr/bin/env bash

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo -e "${BLUE}=== Gem Update Script ===${NC}"

# Check current branch
echo -e "${YELLOW}Checking current branch...${NC}"
CURRENT_BRANCH=$(git branch --show-current)

# Determine if we're on main or an existing update branch
if [ "$CURRENT_BRANCH" = "main" ]; then
  echo -e "${YELLOW}On main branch, will create new update branch${NC}"
  CREATE_NEW_BRANCH=true
  
  echo -e "${YELLOW}Pulling latest changes...${NC}"
  git pull origin main
elif [[ "$CURRENT_BRANCH" == chore/update-gems-* ]]; then
  echo -e "${YELLOW}On existing update branch: ${CURRENT_BRANCH}${NC}"
  echo -e "${YELLOW}Will add updates to this branch${NC}"
  CREATE_NEW_BRANCH=false
  BRANCH_NAME="$CURRENT_BRANCH"
else
  echo -e "${RED}Please run this script from the main branch or an existing chore/update-gems-* branch${NC}"
  exit 1
fi

# Update bundler to latest version
echo -e "${YELLOW}Updating bundler to latest version...${NC}"
gem install bundler --no-document
bundle update --bundler

# Check for outdated gems and capture output
echo -e "${YELLOW}Checking for outdated gems...${NC}"
OUTDATED_OUTPUT=$(bundle outdated --parseable 2>&1 || true)
echo "$OUTDATED_OUTPUT"

# Check if there are any outdated gems
if [ -z "$OUTDATED_OUTPUT" ] || echo "$OUTDATED_OUTPUT" | grep -q "Bundle up to date"; then
  echo -e "${GREEN}✓ No gem updates needed. All gems are up to date!${NC}"
  exit 0
fi

# Parse outdated gems (format: gem-name (newest X.X.X, installed Y.Y.Y, requested ~> Z.Z))
# Extract gem name and newest version
UPDATED_GEMS=()
SKIPPED_GEMS=()

while IFS= read -r line; do
  # Skip empty lines
  [ -z "$line" ] && continue
  
  # Parse gem name and newest version from parseable output
  # Format: gem-name (newest 1.2.3, installed 1.2.0, requested ~> 1.2)
  GEM_NAME=$(echo "$line" | awk '{print $1}')
  NEWEST_VERSION=$(echo "$line" | grep -oE "newest [0-9]+\.[0-9]+(\.[0-9]+)*" | awk '{print $2}')
  
  # Skip if we couldn't parse the gem name or version
  [ -z "$GEM_NAME" ] && continue
  [ -z "$NEWEST_VERSION" ] && continue
  
  echo -e "${YELLOW}Checking gem: ${GEM_NAME}${NC}"
  
  # Check if gem has a comment in Gemfile (indicating breaking changes or pinned version)
  # Match lines like: gem "name" or gem 'name' with optional version, followed by a comment
  if grep -E "gem ['\"]${GEM_NAME}['\"].*#" Gemfile > /dev/null 2>&1; then
    COMMENT=$(grep -E "gem ['\"]${GEM_NAME}['\"]" Gemfile | grep -oE "#.*$" | head -1)
    echo -e "${RED}  ⚠ Skipping ${GEM_NAME} - has comment: ${COMMENT}${NC}"
    SKIPPED_GEMS+=("${GEM_NAME}: ${COMMENT}")
    continue
  fi
  
  # Check if gem exists in Gemfile with a version constraint
  if grep -E "gem ['\"]${GEM_NAME}['\"]" Gemfile > /dev/null 2>&1; then
    # Get current line from Gemfile
    CURRENT_LINE=$(grep -E "gem ['\"]${GEM_NAME}['\"]" Gemfile | head -1)
    
    # Check if it has a version specification
    if echo "$CURRENT_LINE" | grep -E "['\"]~>|['\"][0-9]+\.[0-9]+" > /dev/null 2>&1; then
      # Update the version in Gemfile
      # Handle both gem "name", "~> x.y" and gem "name", "x.y.z" formats
      
      echo -e "${GREEN}  ✓ Updating ${GEM_NAME} to ${NEWEST_VERSION}${NC}"
      
      GEM_NAME_VALUE="$GEM_NAME"
      NEW_VERSION_VALUE="$NEWEST_VERSION"
      GEM_NAME="$GEM_NAME_VALUE" NEW_VERSION="$NEW_VERSION_VALUE" ruby <<'RUBY'
path = 'Gemfile'
name = ENV.fetch('GEM_NAME')
new_version = ENV.fetch('NEW_VERSION')
content = File.read(path)
pattern = Regexp.new(%{^(\s*gem\s+['"]#{Regexp.escape(name)}['"]\s*,\s*)(['"])([^'"]+)(['"])(.*)$}, Regexp::MULTILINE)
updated = false
updated_content = content.gsub(pattern) do
  updated = true
  leading = Regexp.last_match(1)
  quote = Regexp.last_match(2)
  rest = Regexp.last_match(5)
  "#{leading}#{quote}#{new_version}#{quote}#{rest}"
end
unless updated
  warn "Could not update #{name} entry in Gemfile"
  exit 1
end
File.write(path, updated_content)
RUBY
      
      UPDATED_GEMS+=("${GEM_NAME}: updated to ${NEWEST_VERSION}")
    else
      echo -e "${YELLOW}  → ${GEM_NAME} has no version constraint, skipping Gemfile update${NC}"
      UPDATED_GEMS+=("${GEM_NAME}: no version constraint in Gemfile")
    fi
  else
    echo -e "${YELLOW}  → ${GEM_NAME} not found directly in Gemfile (transitive dependency)${NC}"
    UPDATED_GEMS+=("${GEM_NAME}: transitive dependency updated to ${NEWEST_VERSION}")
  fi
done <<< "$OUTDATED_OUTPUT"

# Check if any gems were updated
if [ ${#UPDATED_GEMS[@]} -eq 0 ]; then
  echo -e "${GREEN}✓ No gems could be updated (all have comments or are dependencies).${NC}"
  if [ ${#SKIPPED_GEMS[@]} -gt 0 ]; then
    echo -e "${YELLOW}Skipped gems with comments:${NC}"
    for gem in "${SKIPPED_GEMS[@]}"; do
      echo "  - $gem"
    done
  fi
  exit 0
fi

# Run bundle update to update all gems (including transitive dependencies and implicit gems)
echo -e "${YELLOW}Running bundle update...${NC}"
bundle update --all

# Check if Gemfile or Gemfile.lock changed
if git diff --quiet Gemfile Gemfile.lock 2>/dev/null; then
  echo -e "${GREEN}✓ No actual changes to Gemfile or Gemfile.lock.${NC}"
  exit 0
fi

# Create new branch if we're on main
if [ "$CREATE_NEW_BRANCH" = true ]; then
  BRANCH_NAME="chore/update-gems-$(date +%Y-%m-%d-%H%M%S)"
  echo -e "${YELLOW}Creating branch: ${BRANCH_NAME}${NC}"
  git checkout -b "$BRANCH_NAME"
fi

# Build PR body
PR_TITLE="chore: Update Ruby gems ($(date +%Y-%m-%d))"
PR_BODY="## Gem Updates

This PR updates the following Ruby gems:

### Updated gems
$(for gem in "${UPDATED_GEMS[@]}"; do
  echo "- $gem"
done)

### Skipped gems (have comments indicating breaking changes)
$(if [ ${#SKIPPED_GEMS[@]} -gt 0 ]; then
  for gem in "${SKIPPED_GEMS[@]}"; do
    echo "- $gem"
  done
else
  echo "_None_"
fi)

### Changes to Gemfile
\`\`\`diff
$(git diff Gemfile)
\`\`\`

### Changes to Gemfile.lock
<details>
<summary>Click to expand Gemfile.lock changes</summary>

\`\`\`diff
$(git diff Gemfile.lock)
\`\`\`

</details>

---
*Generated automatically by \`bin/update-gems\`*"

# Commit changes
echo -e "${YELLOW}Committing changes...${NC}"
git add Gemfile Gemfile.lock
git commit -m "$PR_TITLE"

# Push branch
echo -e "${YELLOW}Pushing branch to GitHub...${NC}"
git push -u origin "$BRANCH_NAME"

# Create pull request using GitHub CLI (only if we created a new branch)
if [ "$CREATE_NEW_BRANCH" = true ]; then
  if command -v gh &> /dev/null; then
    echo -e "${YELLOW}Creating pull request...${NC}"
    gh pr create \
      --title "$PR_TITLE" \
      --body "$PR_BODY" \
      --base main \
      --head "$BRANCH_NAME"
    
    echo -e "${GREEN}✓ Pull request created successfully!${NC}"
  else
    echo -e "${RED}GitHub CLI (gh) not installed. Please create the PR manually.${NC}"
    echo -e "${YELLOW}Branch pushed: ${BRANCH_NAME}${NC}"
    echo ""
    echo "PR Title: $PR_TITLE"
    echo ""
    echo "PR Body:"
    echo "$PR_BODY"
  fi
else
  echo -e "${GREEN}✓ Changes pushed to existing branch: ${BRANCH_NAME}${NC}"
  echo -e "${YELLOW}The existing PR will be updated automatically.${NC}"
fi

echo -e "${GREEN}=== Gem update complete! ===${NC}"
